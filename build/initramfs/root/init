#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/sysmacros.h>
#include <sys/wait.h>
#include <unistd.h>

static void log_line(const char *msg) {
    dprintf(STDOUT_FILENO, "[INIT] %s\n", msg);
}

static int run_command(char *const argv[]) {
    pid_t pid = fork();
    if (pid < 0) {
        return -1;
    }
    if (pid == 0) {
        execv(argv[0], argv);
        _exit(127);
    }
    int status = 0;
    if (waitpid(pid, &status, 0) < 0) {
        return -1;
    }
    if (WIFEXITED(status)) {
        return WEXITSTATUS(status);
    }
    return -1;
}

static void ensure_console(void) {
    struct stat st;
    if (stat("/dev/console", &st) != 0) {
        mknod("/dev/console", S_IFCHR | 0600, makedev(5, 1));
    }
    int fd = open("/dev/console", O_RDWR);
    if (fd >= 0) {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
        if (fd > STDERR_FILENO) {
            close(fd);
        }
    }
}

static void mount_fs(const char *type, const char *target) {
    if (mount(type, target, type, 0, "") != 0 && errno != EBUSY) {
        char buf[256];
        snprintf(buf, sizeof(buf), "mount %s on %s failed: %s", type, target, strerror(errno));
        log_line(buf);
    }
}

static const char *read_cmdline_value(const char *key) {
    static char buffer[4096];
    FILE *f = fopen("/proc/cmdline", "r");
    if (!f) {
        return NULL;
    }
    if (!fgets(buffer, sizeof(buffer), f)) {
        fclose(f);
        return NULL;
    }
    fclose(f);

    size_t key_len = strlen(key);
    char *token = buffer;
    while (token != NULL) {
        while (*token == ' ') {
            token++;
        }
        if (token[0] == '\0') {
            break;
        }
        char *next = strchr(token, ' ');
        if (next) {
            *next = '\0';
        }
        if (strncmp(token, key, key_len) == 0 && token[key_len] == '=') {
            return token + key_len + 1;
        }
        if (!next) {
            break;
        }
        token = next + 1;
    }
    return NULL;
}

static bool fetch_manifest(const char *host, const char *plugin, const char *dest) {
    if (!host || !plugin || !dest) {
        return false;
    }
    char url[512];
    snprintf(url, sizeof(url), "http://%s/api/v1/plugins/%s/manifest", host, plugin);

    pid_t pid = fork();
    if (pid < 0) {
        return false;
    }
    if (pid == 0) {
        execl("/bin/wget", "wget", "-q", "-O", dest, url, NULL);
        execl("/bin/curl", "curl", "-sSL", "-o", dest, url, NULL);
        _exit(127);
    }
    int status = 0;
    if (waitpid(pid, &status, 0) < 0) {
        return false;
    }
    return WIFEXITED(status) && WEXITSTATUS(status) == 0;
}

static bool parse_manifest_rootfs(const char *manifest_path, char *url, size_t url_sz, char *checksum, size_t checksum_sz) {
    if (!manifest_path || !url || url_sz == 0) {
        return false;
    }
    FILE *f = fopen(manifest_path, "r");
    if (!f) {
        return false;
    }
    bool url_ok = false;
    bool checksum_ok = false;
    char line[1024];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, "\"rootfs\"")) {
            while (fgets(line, sizeof(line), f)) {
                if (strstr(line, "\"url\"")) {
                    char *start = strchr(line, ':');
                    if (start) {
                        start++;
                        while (*start == ' ' || *start == '"') start++;
                        char *end = start;
                        while (*end && *end != '"' && *end != '\n') end++;
                        size_t len = (size_t)(end - start);
                        if (len >= url_sz) len = url_sz - 1;
                        memcpy(url, start, len);
                        url[len] = '\0';
                        url_ok = true;
                    }
                }
                if (strstr(line, "\"checksum\"")) {
                    char *start = strchr(line, ':');
                    if (start) {
                        start++;
                        while (*start == ' ' || *start == '"') start++;
                        char *end = start;
                        while (*end && *end != '"' && *end != '\n') end++;
                        size_t len = (size_t)(end - start);
                        if (checksum && checksum_sz > 0) {
                            if (len >= checksum_sz) len = checksum_sz - 1;
                            memcpy(checksum, start, len);
                            checksum[len] = '\0';
                        }
                        checksum_ok = true;
                    }
                }
            }
        }
        if (url_ok && checksum_ok) break;
    }
    fclose(f);
    return url_ok;
}

static void ensure_resolv_conf(const char *path) {
    const char *content = "nameserver 1.1.1.1\n";
    if (access(path, F_OK) == 0) {
        return;
    }
    int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        char buf[256];
        snprintf(buf, sizeof(buf), "write resolv.conf %s failed: %s", path, strerror(errno));
        log_line(buf);
        return;
    }
    if (write(fd, content, strlen(content)) < 0) {
        char buf[256];
        snprintf(buf, sizeof(buf), "write resolv.conf %s failed: %s", path, strerror(errno));
        log_line(buf);
    }
    close(fd);
}

int main(void) {
    mount_fs("devtmpfs", "/dev");
    mount_fs("proc", "/proc");
    mount_fs("sysfs", "/sys");
    mount_fs("tmpfs", "/run");

    ensure_console();
    log_line("booting volant init");

    mkdir("/etc", 0755);
    ensure_resolv_conf("/etc/resolv.conf");

    const char *api_host = read_cmdline_value("volant.api_host");
    const char *api_port = read_cmdline_value("volant.api_port");
    const char *plugin_name = read_cmdline_value("volant.plugin");

    const char *manifest_path = "/run/plugin.json";
    const char *rootfs_path = "/run/rootfs.img";

    char rootfs_url[512] = {0};
    char rootfs_checksum[256] = {0};
    if (api_host && api_port && plugin_name && api_host[0] != '\0' && api_port[0] != '\0') {
        char endpoint[512];
        snprintf(endpoint, sizeof(endpoint), "%s:%s", api_host, api_port);
        log_line("fetching plugin manifest");
        if (fetch_manifest(endpoint, plugin_name, manifest_path)) {
            if (!parse_manifest_rootfs(manifest_path, rootfs_url, sizeof(rootfs_url), rootfs_checksum, sizeof(rootfs_checksum))) {
                log_line("manifest missing rootfs url");
            }
        } else {
            log_line("manifest fetch failed");
        }
    } else {
        log_line("missing volant.api_host/api_port or volant.plugin; skipping manifest fetch");
    }

    if (rootfs_url[0] != '\0') {
        log_line("fetching rootfs image");
        mkdir("/sysroot", 0755);
        char *fetch_args[5] = {"/scripts/fetch-rootfs.sh", rootfs_url, (char *)rootfs_path, NULL, NULL};
        if (rootfs_checksum[0] != '\0') {
            fetch_args[3] = rootfs_checksum;
        }
        if (access("/scripts/fetch-rootfs.sh", X_OK) == 0 && run_command(fetch_args) == 0) {
            log_line("rootfs fetched; mounting squashfs");
            char *mount_args[] = {"/bin/mount", "-t", "squashfs", "-o", "loop", (char *)rootfs_path, "/sysroot", NULL};
            if (run_command(mount_args) == 0) {
                mkdir("/sysroot/etc", 0755);
                ensure_resolv_conf("/sysroot/etc/resolv.conf");
                if (access("/sysroot/usr/local/bin/volary", X_OK) == 0) {
                    log_line("switching root");
                    execl("/bin/switch_root", "switch_root", "/sysroot", "/usr/local/bin/volary", NULL);
                    perror("switch_root");
                } else {
                    log_line("volary missing in rootfs; using initramfs copy");
                }
            } else {
                log_line("squashfs mount failed");
            }
        } else {
            log_line("rootfs fetch failed");
        }
    }

    if (access("/usr/local/bin/volary", X_OK) == 0) {
        log_line("launching volary from initramfs");
        execl("/usr/local/bin/volary", "volary", NULL);
        perror("exec volary");
    }

    if (access("/bin/volary", X_OK) == 0) {
        log_line("launching volary from /bin");
        execl("/bin/volary", "volary", NULL);
        perror("exec /bin/volary");
    }

    log_line("volary not found; dropping to shell");
    execl("/bin/sh", "sh", NULL);
    return 1;
}
